import { normalize } from 'node:path';

import { SDK, SDKS } from '../src/datasets/sdks';
import { SdkCompatibilityGenerator } from './sdk-compatibility-generator';

const OPEN_FEATURE_URL = 'https://openfeature.dev';
const DEFAULT_BRANCH = 'main';
const DEFAULT_FILE_EXTENSION = 'mdx';
const GITHUB_ORG = 'open-feature';

/**
 * Converts carriage return characters to new lines. This is an important preprocessing
 * step to ensure subsequent regex's match.
 */
const carriageReturnsToNewLines = (content: string): string => {
  return content.replace(/\r\n/g, '\n');
};

/**
 * Removes emojis from headers.. they look fine in GitHub but awful in the docs.
 */
const removeEmojisFromHeaders = (content: string): string => {
  return content.replace(
    /(#{1,5}) ([\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff]|[\u0023-\u0039]\ufe0f?\u20e3|\u3299|\u3297|\u303d|\u3030|\u24c2|\ud83c[\udd70-\udd71]|\ud83c[\udd7e-\udd7f]|\ud83c\udd8e|\ud83c[\udd91-\udd9a]|\ud83c[\udde6-\uddff]|\ud83c[\ude01-\ude02]|\ud83c\ude1a|\ud83c\ude2f|\ud83c[\ude32-\ude3a]|\ud83c[\ude50-\ude51]|\u203c|\u2049|[\u25aa-\u25ab]|\u25b6|\u25c0|[\u25fb-\u25fe]|\u00a9|\u00ae|\u2122|\u2139|\ud83c\udc04|[\u2600-\u26FF]|\u2b05|\u2b06|\u2b07|\u2b1b|\u2b1c|\u2b50|\u2b55|\u231a|\u231b|\u2328|\u23cf|[\u23e9-\u23f3]|[\u23f8-\u23fa]|\ud83c\udccf|\u2934|\u2935|[\u2190-\u21ff])/g,
    '$1',
  );
};

/**
 * Removes all the content between the markdown comment `x-hide-in-docs-start`
 * and `x-hide-in-docs-end`. This is used to hide information important to the
 * repo but redundant or confusing in the docs.
 */
const removeSections = (content: string): string => {
  return content.replace(/<!-- x-hide-in-docs-start -->(\n|.)*?<!-- x-hide-in-docs-end -->/gm, '');
};

/**
 * Removes all the content on a single line when the markdown comment `x-hide-in-docs`
 * is detected.
 */
const removeLine = (content: string): string => {
  return content.replace(/.*<!-- x-hide-in-docs -->.*/g, '');
};

/**
 * Removes all comments from the readme
 */
const removeComments = (content: string): string => {
  return content.replace(/<!--.*-->/g, '');
};

/**
 * Removes multiple extra lines between sections. These extra lines typically
 * are a result of prior content manipulation.
 */
const removeExtraNewlinesBetweenSections = (content: string): string => {
  return content.replace(/\n*\n{3,}/gm, '\n\n');
};

/**
 * Removes extra lines at the top of the file. These extra lines typically
 * are a result of prior content manipulation.
 */
const removeExtraNewlinesAtTop = (content: string): string => {
  return content.replace(/^[ \t]*\n+/m, '');
};

/**
 * Add header information to the content.
 */
const addHeader =
  (sdk: { name: string; url: string; repo: string; fileName: string; slug?: string; id?: string }) =>
  (content: string): string => {
    const frontmatter: string[] = [];
    frontmatter.push(`title: OpenFeature ${sdk.name} SDK`);
    if (sdk.slug) {
      frontmatter.push(`slug: ${sdk.slug}`);
    }
    if (sdk.id) {
      frontmatter.push(`id: ${sdk.id}`);
    }
    frontmatter.push(`sidebar_label: ${sdk.name}`);
    return `---
${frontmatter.join('\n')}
---

<!--
This content has been automatically generated from ${sdk.repo}.

Edits should be made here: ${sdk.url}
Once a repo has been updated, docs can be generated by running: yarn update:sdk-docs

Last updated at ${new Date()}
-->

${content}`;
  };

/**
 * Fix internal doc links from /technologies/ to /sdks/
 */
const fixInternalDocLinks = (content: string): string => {
  return content.replace(
    /\/docs\/reference\/technologies\//g,
    '/docs/reference/sdks/'
  );
};

const replaceLinks = (repo: { url: string; branch: string; folder?: string }) => {
  return (content: string) => {
    const replace = (processRelativeUrl: (url: string) => string) => (url: string) => {
      try {
        new URL(url);
        return url.replace(OPEN_FEATURE_URL, '');
      } catch {
        return processRelativeUrl(url);
      }
    };

    const replaceMarkdownLink = replace((url) => {
      if (url.startsWith('#')) {
        return url;
      } else if (url.startsWith(OPEN_FEATURE_URL)) {
        return url.replace(OPEN_FEATURE_URL, '');
      } else {
        const folder = repo.folder ?? '';
        // Properly constructs the path even if it's relative.
        const normalizedPath = normalize(`${repo.branch}/${folder}/${url}`);
        return `${repo.url}/blob/${normalizedPath}`;
      }
    });

    const markdownLink = /(?<=\[.*\]\(\s?)([^\s)]+)(?=.*\))/g;

    return content.replaceAll(markdownLink, replaceMarkdownLink);
  };
};

const markdownProcessor = (sdks: SDK[]) => {
  let sdksProcessed = 0;
  const sdkSupportMatrixGenerator = new SdkCompatibilityGenerator();
  // Filter SDKs with repo attribute to get the actual count of SDKs that will be processed
  const sdksWithRepo = sdks.filter((sdk) => sdk.repo);
  return (file: string, initialContent: string): { filename: string; content: string } => {
    const sdk = sdks.find((sdk) => file.startsWith(`${sdk.repo}/${sdk.branch ?? DEFAULT_BRANCH}${sdk.folder ?? ''}/`));

    if (!sdk) {
      throw new Error(`Unable to modify content for ${sdk.repo}`);
    }

    const repoUrl = `https://github.com/${GITHUB_ORG}/${sdk.repo}`;
    const fileName = sdk.filename ?? sdk.name.toLowerCase();
    const fileExtension = sdk.fileExtension ?? DEFAULT_FILE_EXTENSION;
    const branch = sdk.branch ?? DEFAULT_BRANCH;

    const content = [
      carriageReturnsToNewLines,
      removeEmojisFromHeaders,
      removeSections,
      removeLine,
      removeComments,
      removeExtraNewlinesBetweenSections,
      removeExtraNewlinesAtTop,
      addHeader({ name: sdk.name, repo: sdk.repo, url: repoUrl, fileName, slug: sdk.slug, id: sdk.id }),
      replaceLinks({ url: repoUrl, branch, folder: sdk.folder }),
      fixInternalDocLinks,
    ].reduce((currentContent, processor) => processor(currentContent), initialContent);

    if (sdk.includeInSupportMatrix ?? true) {
      sdkSupportMatrixGenerator.addSdk({
        name: sdk.name,
        repoUrl,
        category: sdk.category,
        path: sdk.href,
        content,
      });
    }

    if (sdksProcessed >= sdksWithRepo.length - 1) {
      console.log('processed all sdks... writing matrix to file');
      sdkSupportMatrixGenerator.generateJson('src/datasets/sdks/sdk-compatibility.json');
    }
    sdksProcessed++;

    return {
      filename: `${sdk.category.toLocaleLowerCase()}/${fileName}.${fileExtension}`,
      content,
    };
  };
};

/**
 * Transforms SDK READMEs for inclusion in the OpenFeature docs.
 */
export const processSdkReadmes = {
  paths: SDKS
    // Only include SDKs with a repo. This signifies that the SDK is part of the OpenFeature org.
    .filter((sdk) => sdk.repo)
    .map((sdk) => {
      const branch = sdk.branch ?? 'main';
      const folder = sdk.folder ?? '';
      return `${sdk.repo}/${branch}${folder}/README.md`;
    }),
  modifyContent: markdownProcessor(SDKS),
};

/**
 * Other Technologies content configuration
 */
// TODO: update branches to main once PRs are merged
const OTHER_TECHNOLOGIES = [
  { repo: 'cli', id: 'cli', title: 'OpenFeature CLI', label: 'CLI', position: 1, branch: 'docs-update-readme-for-website' },
  { repo: 'protocol', id: 'ofrep', title: 'OpenFeature Remote Evaluation Protocol (OFREP)', label: 'OFREP', position: 2, branch: 'docs-update-readme-for-website' },
  { repo: 'mcp', id: 'mcp', title: 'OpenFeature MCP Server', label: 'MCP', position: 3, branch: 'docs-improve-readme-and-contributing' },
];

/**
 * Transforms Other Technologies READMEs for inclusion in the OpenFeature docs.
 */
export const processOtherTechnologies = {
  paths: OTHER_TECHNOLOGIES.map((tech) => `${tech.repo}/${tech.branch}/README.md`),
  modifyContent: (file: string, initialContent: string): { filename: string; content: string } => {
    const tech = OTHER_TECHNOLOGIES.find((t) => file.startsWith(`${t.repo}/`));
    
    if (!tech) {
      throw new Error(`Unable to modify content for ${file}`);
    }

    const frontmatter = `---
title: ${tech.title}
sidebar_label: ${tech.label}
sidebar_position: ${tech.position}
id: ${tech.id}
---

`;

    // Convert relative links to absolute GitHub URLs
    const fixRelativeLinks = (content: string): string => {
      const repoUrl = `https://github.com/${GITHUB_ORG}/${tech.repo}`;
      const branch = tech.branch || 'main';
      
      // Convert relative markdown links to GitHub URLs
      return content.replace(
        /\[([^\]]+)\]\(\.\/([^)]+)\)/g,
        (match, text, path) => {
          // Skip if it's already an absolute URL
          if (path.startsWith('http')) return match;
          return `[${text}](${repoUrl}/blob/${branch}/${path})`;
        }
      );
    };

    const processors = [
      carriageReturnsToNewLines,
      removeEmojisFromHeaders,
      removeSections,
      removeLine,
      removeComments,
      removeExtraNewlinesBetweenSections,
      removeExtraNewlinesAtTop,
      fixRelativeLinks,
    ];

    const content = processors.reduce((currentContent, processor) => processor(currentContent), initialContent);

    return {
      filename: `${tech.id}.mdx`,
      content: frontmatter + content,
    };
  },
};
