---
title: OpenFeature iOS SDK
slug: swift
sidebar_label: iOS
---

<!--
This content has been automatically generated from swift-sdk.

Edits should be made here: https://github.com/open-feature/swift-sdk
Once a repo has been updated, docs can be generated by running: yarn update:sdk-docs

Last updated at Wed Feb 18 2026 08:21:16 GMT+0000 (Coordinated Universal Time)
-->
import MCPInstall from '@site/src/partials/mcp-install';


<p align="center" class="github-badges">

  <a href="https://github.com/open-feature/spec/releases/tag/v0.8.0">
    <img alt="Specification" src="https://img.shields.io/static/v1?label=specification&message=v0.8.0&color=yellow&style=for-the-badge" />
  </a>
  

  <a href="https://github.com/open-feature/swift-sdk/releases/tag/0.5.0">
    <img alt="Release" src="https://img.shields.io/static/v1?label=release&message=v0.5.0&color=blue&style=for-the-badge" />
  </a>

  
  <br/>
  <img alt="Status" src="https://img.shields.io/badge/lifecycle-alpha-a0c3d2.svg" />
</p>

## Quick start

<MCPInstall sdkTechnology="swift" />


### Requirements

This SDK supports the following Apple platforms:
- **iOS 14+**
- **macOS 11+**
- **watchOS 7+**
- **tvOS 14+**

The SDK is built with Swift 5.5+ and uses only Foundation and Combine frameworks, making it suitable for all Apple platform contexts including mobile, desktop, wearable, and TV applications.

### Install

#### Xcode Dependencies

You have two options, both start from File > Add Packages... in the code menu.

First, ensure you have your GitHub account added as an option (+ > Add Source Control Account...). You will need to create a [Personal Access Token](https://github.com/settings/tokens) with the permissions defined in the Xcode interface.

1. Add as a remote repository
    * Search for `git@github.com:open-feature/swift-sdk.git` and click "Add Package"
2. Clone the repository locally
    * Clone locally using your preferred method
    * Use the "Add Local..." button to select the local folder

**Note:** Option 2 is only recommended if you are making changes to the client SDK.

#### Swift Package Manager

If you manage dependencies through SPM, in the dependencies section of Package.swift add:

```swift
.package(url: "git@github.com:open-feature/swift-sdk.git", from: "0.5.0")
```

and in the target dependencies section add:
```swift
.product(name: "OpenFeature", package: "swift-sdk"),
```

#### CocoaPods

If you manage dependencies through CocoaPods, add the following to your Podfile:

```ruby
pod 'OpenFeature', '~> 0.3.0'
```

Then, run:

```bash
pod install
```

### iOS Usage

```swift
import OpenFeature

Task {
    let provider = CustomProvider()
    // configure a provider, wait for it to complete its initialization tasks
    await OpenFeatureAPI.shared.setProviderAndWait(provider: provider)

    // get a bool flag value
    let client = OpenFeatureAPI.shared.getClient()
    let flagValue = client.getBooleanValue(key: "boolFlag", defaultValue: false)
}
```

## Features

| Status | Features                        | Description                                                                                                                         |
| ------ | ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| ✅     | [Providers](#providers)         | Integrate with a commercial, open source, or in-house feature management tool.                                                      |
| ✅     | [Targeting](#targeting)         | Contextually-aware flag evaluation using [evaluation context](/docs/reference/concepts/evaluation-context).  |
| ✅     | [Hooks](#hooks)                 | Add functionality to various stages of the flag evaluation life-cycle.                                                              |
| ✅     | [Tracking](#tracking)           | Associate user actions with feature flag evaluations.                                                                               |
| ✅     | [Logging](#logging)             | Integrate with popular logging packages.                                                                                            |
| ❌     | [Domains](#domains)             | Logically bind clients with providers.                                                                                              |
| ✅     | [MultiProvider](#multiprovider) | Combine multiple providers with configurable evaluation strategies.                                                                 |
| ✅     | [Eventing](#eventing)           | React to state changes in the provider or flag management system.                                                                   |
| ❌     | [Shutdown](#shutdown)           | Gracefully clean up a provider during application shutdown.                                                                         |
| ✅     | [Extending](#extending)         | Extend OpenFeature with custom providers and hooks.                                                                                 |

<sub>Implemented: ✅ | In-progress: ⚠️ | Not implemented yet: ❌</sub>

### Providers

[Providers](/docs/reference/concepts/provider) are an abstraction between a flag management system and the OpenFeature SDK.
Look [here](/ecosystem?instant_search%5BrefinementList%5D%5Btype%5D%5B0%5D=Provider&instant_search%5BrefinementList%5D%5Btechnology%5D%5B0%5D=Swift) for a complete list of available providers.
If the provider you're looking for hasn't been created yet, see the [develop a provider](#develop-a-provider) section to learn how to build it yourself.

Once you've added a provider as a dependency, it can be registered with OpenFeature like this:

```swift
await OpenFeatureAPI.shared.setProviderAndWait(provider: MyProvider())
```

> Asynchronous API that doesn't wait is also available

### Targeting

Sometimes, the value of a flag must consider some dynamic criteria about the application or user, such as the user's location, IP, email address, or the server's location.
In OpenFeature, we refer to this as [targeting](/specification/glossary#targeting).
If the flag management system you're using supports targeting, you can provide the input data using the [evaluation context](/docs/reference/concepts/evaluation-context).

```swift
// Configure your evaluation context and pass it to OpenFeatureAPI
let ctx = ImmutableContext(
    targetingKey: userId,
    structure: ImmutableStructure(attributes: ["product": Value.string(productId)]))
OpenFeatureAPI.shared.setEvaluationContext(evaluationContext: ctx)
```

### Hooks

[Hooks](/docs/reference/concepts/hooks) allow for custom logic to be added at well-defined points of the flag evaluation life-cycle.
Look [here](/ecosystem/?instant_search%5BrefinementList%5D%5Btype%5D%5B0%5D=Hook&instant_search%5BrefinementList%5D%5Btechnology%5D%5B0%5D=Swift) for a complete list of available hooks.
If the hook you're looking for hasn't been created yet, see the [develop a hook](#develop-a-hook) section to learn how to build it yourself.

Once you've added a hook as a dependency, it can be registered at the global, client, or flag invocation level.

```swift
// add a hook globally, to run on all evaluations
OpenFeatureAPI.shared.addHooks(hooks: ExampleHook())

// add a hook on this client, to run on all evaluations made by this client
let client = OpenFeatureAPI.shared.getClient()
client.addHooks(ExampleHook())

// add a hook for this evaluation only
_ = client.getValue(
    key: "key",
    defaultValue: false,
    options: FlagEvaluationOptions(hooks: [ExampleHook()]))
```
### Tracking

The tracking API allows you to use OpenFeature abstractions and objects to associate user actions with feature flag evaluations.
This is essential for robust experimentation powered by feature flags.
For example, a flag enhancing the appearance of a UI component might drive user engagement to a new feature; to test this hypothesis, telemetry collected by a [hook](#hooks) or [provider](#providers) can be associated with telemetry reported in the client's `track` function.

```swift
let client = OpenFeatureAPI.shared.getClient()

// Track an event
client.track(key: "test")

// Track an event with a numeric value
client.track(key: "test-value", details: ImmutableTrackingEventDetails(value: 5))
```

Note that some providers may not support tracking; check the documentation for your provider for more information.

### Logging

The iOS SDK integrates with [swift-log](https://github.com/apple/swift-log), the standard logging API for Swift. This provides a unified, cross-platform logging interface that works with any swift-log compatible backend.

#### Configure Logger

You can configure logging at three levels, with each level taking precedence over the previous:

**1. Global (API-level)** - affects all flag evaluations:
```swift
import Logging

let logger = Logger(label: "com.example.app.openfeature")
OpenFeatureAPI.shared.setLogger(logger)
```

**2. Client-level** - affects all evaluations from a specific client:
```swift
let client = OpenFeatureAPI.shared.getClient()
let logger = Logger(label: "com.example.app.flags")
client.setLogger(logger)
```

**3. Evaluation-level** - affects a single flag evaluation:
```swift
let logger = Logger(label: "com.example.app.critical-flag")
let options = FlagEvaluationOptions(logger: logger)
let value = client.getBooleanValue(key: "my-flag", defaultValue: false, options: options)
```

#### Provider Support

Providers can optionally use the logger for debugging and diagnostics. The logger is passed to providers during flag evaluation, allowing them to log relevant information.

If no logger is configured, logging is disabled. The logger is completely optional for both SDK users and provider authors.

### Domains

Domains allow you to logically bind clients with providers, enabling the use of multiple providers within a single application. Each domain can have its own provider, and clients can be associated with a specific domain.

Support for domains is not yet available in the iOS SDK.

### MultiProvider

The `MultiProvider` allows you to combine multiple feature flag providers into a single provider, enabling you to use different providers for different flags or implement fallback mechanisms. This is useful when migrating between providers, implementing A/B testing across providers, or ensuring high availability.

#### Basic Usage

```swift
import OpenFeature

Task {
    // Create individual providers
    let primaryProvider = PrimaryProvider()
    let fallbackProvider = FallbackProvider()
    
    // Create a MultiProvider with default FirstMatchStrategy
    let multiProvider = MultiProvider(providers: [primaryProvider, fallbackProvider])
    
    // Set the MultiProvider as the global provider
    await OpenFeatureAPI.shared.setProviderAndWait(provider: multiProvider)
    
    // Use flags normally - the MultiProvider will handle provider selection
    let client = OpenFeatureAPI.shared.getClient()
    let flagValue = client.getBooleanValue(key: "my-flag", defaultValue: false)
}
```

#### Evaluation Strategies

The `MultiProvider` supports different strategies for evaluating flags across multiple providers:

##### FirstMatchStrategy (Default)

The `FirstMatchStrategy` evaluates providers in order and returns the first result that doesn't indicate "flag not found". If a provider returns an error other than "flag not found", that error is returned immediately.

```swift
let multiProvider = MultiProvider(
    providers: [primaryProvider, fallbackProvider],
    strategy: FirstMatchStrategy()
)
```

##### FirstSuccessfulStrategy

The `FirstSuccessfulStrategy` evaluates providers in order and returns the first successful result (no error). Unlike `FirstMatchStrategy`, it continues to the next provider if any error occurs, including "flag not found".

```swift
let multiProvider = MultiProvider(
    providers: [primaryProvider, fallbackProvider],
    strategy: FirstSuccessfulStrategy()
)
```

#### Use Cases

**Provider Migration:**
```swift
// Gradually migrate from OldProvider to NewProvider
let multiProvider = MultiProvider(providers: [
    NewProvider(),  // Check new provider first
    OldProvider()   // Fall back to old provider
])
```

**High Availability:**
```swift
// Use multiple providers for redundancy
let multiProvider = MultiProvider(providers: [
    RemoteProvider(),
    LocalCacheProvider(),
    StaticProvider()
])
```

**Environment-Specific Providers:**
```swift
// Different providers for different environments
let providers = [
    EnvironmentProvider(environment: "production"),
    DefaultProvider()
]
let multiProvider = MultiProvider(providers: providers)
```

### Eventing

Events allow you to react to state changes in the provider or underlying flag management system, such as flag definition changes, provider readiness, or error conditions.
Initialization events (`PROVIDER_READY` on success, `PROVIDER_ERROR` on failure) are dispatched for every provider.
Some providers support additional events, such as `PROVIDER_CONFIGURATION_CHANGED`.

Please refer to the documentation of the provider you're using to see what events are supported.

```swift
let cancellable = OpenFeatureAPI.shared.observe().sink { event in
    switch event {
    case ProviderEvent.ready:
        // ...
    default:
        // ...
    }
}
```

### Shutdown

A shutdown function is not yet available in the iOS SDK.

## Extending

### Develop a provider

To develop a provider, you need to create a new project and include the OpenFeature SDK as a dependency.
You'll then need to write the provider by implementing the `FeatureProvider` interface exported by the OpenFeature SDK.

```swift
import OpenFeature

final class CustomProvider: FeatureProvider {
    var hooks: [any Hook] = []
    var metadata: ProviderMetadata = CustomMetadata()

    func initialize(initialContext: EvaluationContext?) async {
        // add context-aware provider initialisation
    }

    func onContextSet(oldContext: EvaluationContext?, newContext: EvaluationContext) async {
        // add necessary changes on context change
    }

    func getBooleanEvaluation(
        key: String,
        defaultValue: Bool,
        context: EvaluationContext?
    ) throws -> ProviderEvaluation<Bool> {
        // resolve a boolean flag value
    }

    ...
}

```
> Built a new provider? [Let us know](https://github.com/open-feature/openfeature.dev/issues/new?assignees=&labels=provider&projects=&template=document-provider.yaml&title=%5BProvider%5D%3A+) so we can add it to the docs!

### Develop a hook

To develop a hook, you need to create a new project and include the OpenFeature SDK as a dependency.
Implement your own hook by conforming to the `Hook interface`.
To satisfy the interface, all methods (`Before`/`After`/`Finally`/`Error`) need to be defined.

```swift
class BooleanHook: Hook {
    typealias HookValue = Bool

    func before<HookValue>(ctx: HookContext<HookValue>, hints: [String: Any]) {
        // do something
    }

    func after<HookValue>(ctx: HookContext<HookValue>, details: FlagEvaluationDetails<HookValue>, hints: [String: Any]) {
        // do something
    }

    func error<HookValue>(ctx: HookContext<HookValue>, error: Error, hints: [String: Any]) {
        // do something
    }

    func finally<HookValue>(ctx: HookContext<HookValue>, hints: [String: Any]) {
        // do something
    }
}
```

> Built a new hook? [Let us know](https://github.com/open-feature/openfeature.dev/issues/new?assignees=&labels=hook&projects=&template=document-hook.yaml&title=%5BHook%5D%3A+) so we can add it to the docs!

