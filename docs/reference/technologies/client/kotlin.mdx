---
title: OpenFeature Android SDK
slug: kotlin
sidebar_label: Android
---

<!--
This content has been automatically generated from kotlin-sdk.

Edits should be made here: https://github.com/open-feature/kotlin-sdk
Once a repo has been updated, docs can be generated by running: yarn update:sdk-docs

Last updated at Thu Mar 13 2025 08:09:33 GMT+0000 (Coordinated Universal Time)
-->

<p align="center" class="github-badges">
  <a href="https://github.com/open-feature/spec/releases/tag/v0.8.0">
    <img alt="Specification" src="https://img.shields.io/static/v1?label=specification&message=v0.8.0&color=yellow&style=for-the-badge" />
  </a>
  
  <a href="https://github.com/open-feature/kotlin-sdk/releases/tag/v0.4.1">
    <img alt="Release" src="https://img.shields.io/static/v1?label=release&message=v0.4.1&color=blue&style=for-the-badge" />
  </a>
  
  <br/>
  <img alt="Status" src="https://img.shields.io/badge/lifecycle-alpha-a0c3d2.svg" />
  <a href="https://mvnrepository.com/artifact/dev.openfeature/android-sdk">
    <img alt="MavenCentral" src="https://img.shields.io/maven-central/v/dev.openfeature/android-sdk" />
  </a>
</p>

## Quick start

### Requirements

- The Android minSdk version supported is: `21`.

Note that this library is intended to be used in a mobile context, and has not been evaluated for use in other types of applications (e.g. server applications).

### Install

#### Maven Central

Installation via Maven Central is preferred, using the following dependency:

```kotlin
dependencies {
    api("dev.openfeature:android-sdk:0.4.1")
}
```

### Usage

```kotlin
coroutineScope.launch(Dispatchers.IO) {
  // configure a provider, wait for it to complete its initialization tasks
  OpenFeatureAPI.setProviderAndWait(customProvider)
  val client = OpenFeatureAPI.getClient()

  // get a bool flag value
  client.getBooleanValue("boolFlag", default = false)
}
```

## Features

| Status | Features                        | Description                                                                                                                        |
|--------|---------------------------------|------------------------------------------------------------------------------------------------------------------------------------|
| ✅      | [Providers](#providers)         | Integrate with a commercial, open source, or in-house feature management tool.                                                     |
| ✅      | [Targeting](#targeting)         | Contextually-aware flag evaluation using [evaluation context](/docs/reference/concepts/evaluation-context). |
| ✅      | [Hooks](#hooks)                 | Add functionality to various stages of the flag evaluation life-cycle.                                                             |
| ✅      | [Tracking](#tracking)           | Associate user actions with feature flag evaluations.                                                                              |
| ❌      | [Logging](#logging)             | Integrate with popular logging packages.                                                                                           |
| ❌      | [Named clients](#named-clients) | Utilize multiple providers in a single application.                                                                                |
| ✅      | [Eventing](#eventing)           | React to state changes in the provider or flag management system.                                                                  |
| ✅      | [Shutdown](#shutdown)           | Gracefully clean up a provider during application shutdown.                                                                        |
| ⚠️     | [Extending](#extending)         | Extend OpenFeature with custom providers and hooks.                                                                                |

<sub>Implemented: ✅ | In-progress: ⚠️ | Not implemented yet: ❌</sub>

### Providers

[Providers](/docs/reference/concepts/provider) are an abstraction between a flag management system and the OpenFeature SDK.
Look [here](/ecosystem?instant_search%5BrefinementList%5D%5Btype%5D%5B0%5D=Provider&instant_search%5BrefinementList%5D%5Btechnology%5D%5B0%5D=kotlin) for a complete list of available providers.
If the provider you're looking for hasn't been created yet, see the [develop a provider](#develop-a-provider) section to learn how to build it yourself.

Once you've added a provider as a dependency, it can be registered with OpenFeature like this:

```kotlin
coroutineScope.launch(Dispatchers.IO) {
    OpenFeatureAPI.setProviderAndWait(MyProvider())
}
```

Asynchronous API that doesn't wait is also available. It's useful when you want to set a provider and continue with other tasks.

However, flag evaluations are only possible after the provider is Ready.

```kotlin
OpenFeatureAPI.setProvider(MyProvider()) // can pass a dispatcher here
// The provider initialization happens on a coroutine launched on the IO dispatcher. 
val status = OpenFeatureAPI.getStatus()
// When status is Ready, flag evaluations can be made
```

### Targeting

Sometimes, the value of a flag must consider some dynamic criteria about the application or user, such as the user's location, IP, email address, or the server's location.
In OpenFeature, we refer to this as [targeting](/specification/glossary#targeting).
If the flag management system you're using supports targeting, you can provide the input data using the [evaluation context](/docs/reference/concepts/evaluation-context).

```kotlin
// set a value to the global context
val evaluationContext = ImmutableContext(
    targetingKey = session.getId,
    attributes = mutableMapOf("region" to Value.String("us-east-1")))
OpenFeatureAPI.setEvaluationContext(evaluationContext)
```

### Hooks

[Hooks](/docs/reference/concepts/hooks) allow for custom logic to be added at well-defined points of the flag evaluation life-cycle.
Look [here](/ecosystem/?instant_search%5BrefinementList%5D%5Btype%5D%5B0%5D=Hook&instant_search%5BrefinementList%5D%5Btechnology%5D%5B0%5D=kotlin) for a complete list of available hooks.
If the hook you're looking for hasn't been created yet, see the [develop a hook](#develop-a-hook) section to learn how to build it yourself.

Once you've added a hook as a dependency, it can be registered at the global, client, or flag invocation level.

```kotlin
// add a hook globally, to run on all evaluations
OpenFeatureAPI.addHooks(listOf(ExampleHook()))

// add a hook on this client, to run on all evaluations made by this client
val client = OpenFeatureAPI.getClient()
client.addHooks(listOf(ExampleHook()))

// add a hook for this evaluation only
val retval = client.getBooleanValue(flagKey, false,
    FlagEvaluationOptions(listOf(ExampleHook())))
```

### Tracking

The [tracking API](/specification/sections/tracking/) allows you to use 
OpenFeature abstractions to associate user actions with feature flag evaluations.
This is essential for robust experimentation powered by feature flags. Note that, unlike methods 
that handle feature flag evaluations, calling `track(...)` may throw an `IllegalArgumentException` 
if an empty string is passed as the `trackingEventName`.

Below is an example of how we can track a "Checkout" event with some `TrackingDetails`.

```kotlin
OpenFeatureAPI.getClient().track(
  "Checkout",
  TrackingEventDetails(
    499.99,
    ImmutableStructure(
      "numberOfItems" to Value.Integer(4),
      "timeInCheckout" to Value.String("PT3M20S")
    )
  )
)
```

Tracking is optionally implemented by Providers.

### Logging

Logging customization is not yet available in the Kotlin SDK.

It is possible to write and inject logging `Hook`s to log events at different stages of the flag evaluation life-cycle.

### Named clients

Support for named clients is not yet available in the Kotlin SDK.

### Eventing

Events from the Provider allow the SDK to react to state changes in the provider or underlying flag management system, such as flag definition changes, provider readiness, or error conditions.
Events are optional which mean that not all Providers will emit them and it is not a must have. Some providers support additional events, such as `PROVIDER_CONFIGURATION_CHANGED`.

Please refer to the documentation of the provider you're using to see what events are supported.

Example usage:
```kotlin
viewModelScope.launch {
  OpenFeatureAPI.observe().collect {
    println(">> Provider event received")
  }
}

viewModelScope.launch {
  OpenFeatureAPI.setProviderAndWait(
    MyFeatureProvider(),
    Dispatchers.IO,
    myEvaluationContext
  )
}
```

### Shutdown

The OpenFeature API provides a close function to perform a cleanup of the registered provider.
This should only be called when your application is in the process of shutting down.

```kotlin
OpenFeatureAPI.shutdown()
```

## Extending

### Develop a provider

To develop a provider, you need to create a new project and include the OpenFeature SDK as a dependency.
You’ll then need to write the provider by implementing the `FeatureProvider` interface exported by the OpenFeature SDK.

```kotlin
class NewProvider(override val hooks: List<Hook<*>>, override val metadata: Metadata) : FeatureProvider {
    override fun getBooleanEvaluation(
        key: String,
        defaultValue: Boolean,
        context: EvaluationContext?
    ): ProviderEvaluation<Boolean> {
        // resolve a boolean flag value
    }

    override fun getDoubleEvaluation(
        key: String,
        defaultValue: Double,
        context: EvaluationContext?
    ): ProviderEvaluation<Double> {
        // resolve a double flag value
    }

    override fun getIntegerEvaluation(
        key: String,
        defaultValue: Int,
        context: EvaluationContext?
    ): ProviderEvaluation<Int> {
        // resolve an integer flag value
    }

    override fun getObjectEvaluation(
        key: String,
        defaultValue: Value,
        context: EvaluationContext?
    ): ProviderEvaluation<Value> {
        // resolve an object flag value
    }

    override fun getStringEvaluation(
        key: String,
        defaultValue: String,
        context: EvaluationContext?
    ): ProviderEvaluation<String> {
        // resolve a string flag value
    }

    override suspend fun initialize(initialContext: EvaluationContext?) {
        // add context-aware provider initialization
    }

    override suspend fun onContextSet(oldContext: EvaluationContext?, newContext: EvaluationContext) {
        // add necessary changes on context change
    }
  
    override fun track(
      trackingEventName: String,
      context: EvaluationContext?,
      details: TrackingEventDetails?
    ) {
      // Optionally track an event
    }
  
    override fun observe(): Flow<OpenFeatureProviderEvents> {
        // Optionally return a `Flow` of OpenFeatureProviderEvents
    }
}
```

> Built a new provider? [Let us know](https://github.com/open-feature/openfeature.dev/issues/new?assignees=&labels=provider&projects=&template=document-provider.yaml&title=%5BProvider%5D%3A+) so we can add it to the docs!

### Develop a hook

To develop a hook, you need to create a new project and include the OpenFeature SDK as a dependency.
Implement your own hook by conforming to the `Hook` interface exported by the OpenFeature SDK.

> Built a new hook? [Let us know](https://github.com/open-feature/openfeature.dev/issues/new?assignees=&labels=hook&projects=&template=document-hook.yaml&title=%5BHook%5D%3A+) so we can add it to the docs!

